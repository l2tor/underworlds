// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: underworlds.proto
#ifndef GRPC_underworlds_2eproto__INCLUDED
#define GRPC_underworlds_2eproto__INCLUDED

#include "underworlds.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace underworlds {

class Underworlds GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GENERAL
    //
    // Establish the connection to the server, setting a human-friendly name for
    // the client.
    // The server returns a unique client ID that must be used in every subsequent
    // request to the server.
    virtual ::grpc::Status helo(::grpc::ClientContext* context, const ::underworlds::Name& request, ::underworlds::Client* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Client>> Asynchelo(::grpc::ClientContext* context, const ::underworlds::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Client>>(AsyncheloRaw(context, request, cq));
    }
    // Returns the uptime of the server, in seconds
    virtual ::grpc::Status uptime(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Time* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>> Asyncuptime(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>>(AsyncuptimeRaw(context, request, cq));
    }
    // Returns the current topology of underworlds: the list of worlds and the
    // list of clients + their interactions with the worlds
    virtual ::grpc::Status topology(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Topology* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Topology>> Asynctopology(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Topology>>(AsynctopologyRaw(context, request, cq));
    }
    // Hard reset of Underworlds: the whole network is deleted: worlds, clients
    // The existing mesh database is kept, however.
    virtual ::grpc::Status reset(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> Asyncreset(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncresetRaw(context, request, cq));
    }
    // NODES
    //
    // Returns the number of nodes in a given world.
    // 
    // Accepts a context (client ID and world) and returns the number of existing nodes.
    virtual ::grpc::Status getNodesLen(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Size* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Size>> AsyncgetNodesLen(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Size>>(AsyncgetNodesLenRaw(context, request, cq));
    }
    // Returns the list of node IDs present in the given world
    virtual ::grpc::Status getNodesIds(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Nodes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Nodes>> AsyncgetNodesIds(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Nodes>>(AsyncgetNodesIdsRaw(context, request, cq));
    }
    // Returns the root node ID of the given world
    virtual ::grpc::Status getRootNode(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Node* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>> AsyncgetRootNode(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>>(AsyncgetRootNodeRaw(context, request, cq));
    }
    // Returns a node from its ID in the given world.
    // Note that only the node ID is used (and thus, required).
    virtual ::grpc::Status getNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Node* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>> AsyncgetNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>>(AsyncgetNodeRaw(context, request, cq));
    }
    // Updates (and broadcasts to all client) a node in a given world
    virtual ::grpc::Status updateNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> AsyncupdateNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncupdateNodeRaw(context, request, cq));
    }
    // Deletes (and broadcasts to all client) a node in a given world
    virtual ::grpc::Status deleteNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> AsyncdeleteNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncdeleteNodeRaw(context, request, cq));
    }
    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    std::unique_ptr< ::grpc::ClientReaderInterface< ::underworlds::NodeInvalidation>> getNodeInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::underworlds::NodeInvalidation>>(getNodeInvalidationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::underworlds::NodeInvalidation>> AsyncgetNodeInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::underworlds::NodeInvalidation>>(AsyncgetNodeInvalidationsRaw(context, request, cq, tag));
    }
    // TIMELINE
    //
    // Returns the timeline origin: time of the timeline creation
    virtual ::grpc::Status timelineOrigin(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Time* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>> AsynctimelineOrigin(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>>(AsynctimelineOriginRaw(context, request, cq));
    }
    // Notifies the server that an event occured
    virtual ::grpc::Status event(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> Asyncevent(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsynceventRaw(context, request, cq));
    }
    // Notifies the server that a specific situation has started
    virtual ::grpc::Status startSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> AsyncstartSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncstartSituationRaw(context, request, cq));
    }
    // Notifies the server that a specific situation has ended
    virtual ::grpc::Status endSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> AsyncendSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncendSituationRaw(context, request, cq));
    }
    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    std::unique_ptr< ::grpc::ClientReaderInterface< ::underworlds::TimelineInvalidation>> getTimelineInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::underworlds::TimelineInvalidation>>(getTimelineInvalidationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::underworlds::TimelineInvalidation>> AsyncgetTimelineInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::underworlds::TimelineInvalidation>>(AsyncgetTimelineInvalidationsRaw(context, request, cq, tag));
    }
    // MESHES
    //
    // Returns whether the given mesh is already available on the server.
    // Note that only the mesh ID is used.
    virtual ::grpc::Status hasMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Bool>> AsynchasMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Bool>>(AsynchasMeshRaw(context, request, cq));
    }
    // Returns a 3D mesh.
    // Note that only the ID of the input mesh is used.
    virtual ::grpc::Status getMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Mesh* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Mesh>> AsyncgetMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Mesh>>(AsyncgetMeshRaw(context, request, cq));
    }
    // Sends a 3D mesh to the server.
    virtual ::grpc::Status pushMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>> AsyncpushMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>>(AsyncpushMeshRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Client>* AsyncheloRaw(::grpc::ClientContext* context, const ::underworlds::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>* AsyncuptimeRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Topology>* AsynctopologyRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncresetRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Size>* AsyncgetNodesLenRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Nodes>* AsyncgetNodesIdsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>* AsyncgetRootNodeRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Node>* AsyncgetNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncupdateNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncdeleteNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::underworlds::NodeInvalidation>* getNodeInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::underworlds::NodeInvalidation>* AsyncgetNodeInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Time>* AsynctimelineOriginRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsynceventRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncstartSituationRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncendSituationRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::underworlds::TimelineInvalidation>* getTimelineInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::underworlds::TimelineInvalidation>* AsyncgetTimelineInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Bool>* AsynchasMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Mesh>* AsyncgetMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::underworlds::Empty>* AsyncpushMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status helo(::grpc::ClientContext* context, const ::underworlds::Name& request, ::underworlds::Client* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Client>> Asynchelo(::grpc::ClientContext* context, const ::underworlds::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Client>>(AsyncheloRaw(context, request, cq));
    }
    ::grpc::Status uptime(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Time* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Time>> Asyncuptime(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Time>>(AsyncuptimeRaw(context, request, cq));
    }
    ::grpc::Status topology(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Topology* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Topology>> Asynctopology(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Topology>>(AsynctopologyRaw(context, request, cq));
    }
    ::grpc::Status reset(::grpc::ClientContext* context, const ::underworlds::Client& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> Asyncreset(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncresetRaw(context, request, cq));
    }
    ::grpc::Status getNodesLen(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Size* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Size>> AsyncgetNodesLen(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Size>>(AsyncgetNodesLenRaw(context, request, cq));
    }
    ::grpc::Status getNodesIds(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Nodes* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Nodes>> AsyncgetNodesIds(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Nodes>>(AsyncgetNodesIdsRaw(context, request, cq));
    }
    ::grpc::Status getRootNode(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Node* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Node>> AsyncgetRootNode(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Node>>(AsyncgetRootNodeRaw(context, request, cq));
    }
    ::grpc::Status getNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Node* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Node>> AsyncgetNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Node>>(AsyncgetNodeRaw(context, request, cq));
    }
    ::grpc::Status updateNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> AsyncupdateNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncupdateNodeRaw(context, request, cq));
    }
    ::grpc::Status deleteNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> AsyncdeleteNode(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncdeleteNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::underworlds::NodeInvalidation>> getNodeInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::underworlds::NodeInvalidation>>(getNodeInvalidationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::underworlds::NodeInvalidation>> AsyncgetNodeInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::underworlds::NodeInvalidation>>(AsyncgetNodeInvalidationsRaw(context, request, cq, tag));
    }
    ::grpc::Status timelineOrigin(::grpc::ClientContext* context, const ::underworlds::Context& request, ::underworlds::Time* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Time>> AsynctimelineOrigin(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Time>>(AsynctimelineOriginRaw(context, request, cq));
    }
    ::grpc::Status event(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> Asyncevent(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsynceventRaw(context, request, cq));
    }
    ::grpc::Status startSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> AsyncstartSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncstartSituationRaw(context, request, cq));
    }
    ::grpc::Status endSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> AsyncendSituation(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncendSituationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::underworlds::TimelineInvalidation>> getTimelineInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::underworlds::TimelineInvalidation>>(getTimelineInvalidationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::underworlds::TimelineInvalidation>> AsyncgetTimelineInvalidations(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::underworlds::TimelineInvalidation>>(AsyncgetTimelineInvalidationsRaw(context, request, cq, tag));
    }
    ::grpc::Status hasMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Bool* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Bool>> AsynchasMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Bool>>(AsynchasMeshRaw(context, request, cq));
    }
    ::grpc::Status getMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Mesh* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Mesh>> AsyncgetMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Mesh>>(AsyncgetMeshRaw(context, request, cq));
    }
    ::grpc::Status pushMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::underworlds::Empty* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>> AsyncpushMesh(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>>(AsyncpushMeshRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Client>* AsyncheloRaw(::grpc::ClientContext* context, const ::underworlds::Name& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Time>* AsyncuptimeRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Topology>* AsynctopologyRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncresetRaw(::grpc::ClientContext* context, const ::underworlds::Client& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Size>* AsyncgetNodesLenRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Nodes>* AsyncgetNodesIdsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Node>* AsyncgetRootNodeRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Node>* AsyncgetNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncupdateNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncdeleteNodeRaw(::grpc::ClientContext* context, const ::underworlds::NodeInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientReader< ::underworlds::NodeInvalidation>* getNodeInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request) GRPC_OVERRIDE;
    ::grpc::ClientAsyncReader< ::underworlds::NodeInvalidation>* AsyncgetNodeInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Time>* AsynctimelineOriginRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsynceventRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncstartSituationRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncendSituationRaw(::grpc::ClientContext* context, const ::underworlds::SituationInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientReader< ::underworlds::TimelineInvalidation>* getTimelineInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request) GRPC_OVERRIDE;
    ::grpc::ClientAsyncReader< ::underworlds::TimelineInvalidation>* AsyncgetTimelineInvalidationsRaw(::grpc::ClientContext* context, const ::underworlds::Context& request, ::grpc::CompletionQueue* cq, void* tag) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Bool>* AsynchasMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Mesh>* AsyncgetMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::underworlds::Empty>* AsyncpushMeshRaw(::grpc::ClientContext* context, const ::underworlds::MeshInContext& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_helo_;
    const ::grpc::RpcMethod rpcmethod_uptime_;
    const ::grpc::RpcMethod rpcmethod_topology_;
    const ::grpc::RpcMethod rpcmethod_reset_;
    const ::grpc::RpcMethod rpcmethod_getNodesLen_;
    const ::grpc::RpcMethod rpcmethod_getNodesIds_;
    const ::grpc::RpcMethod rpcmethod_getRootNode_;
    const ::grpc::RpcMethod rpcmethod_getNode_;
    const ::grpc::RpcMethod rpcmethod_updateNode_;
    const ::grpc::RpcMethod rpcmethod_deleteNode_;
    const ::grpc::RpcMethod rpcmethod_getNodeInvalidations_;
    const ::grpc::RpcMethod rpcmethod_timelineOrigin_;
    const ::grpc::RpcMethod rpcmethod_event_;
    const ::grpc::RpcMethod rpcmethod_startSituation_;
    const ::grpc::RpcMethod rpcmethod_endSituation_;
    const ::grpc::RpcMethod rpcmethod_getTimelineInvalidations_;
    const ::grpc::RpcMethod rpcmethod_hasMesh_;
    const ::grpc::RpcMethod rpcmethod_getMesh_;
    const ::grpc::RpcMethod rpcmethod_pushMesh_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GENERAL
    //
    // Establish the connection to the server, setting a human-friendly name for
    // the client.
    // The server returns a unique client ID that must be used in every subsequent
    // request to the server.
    virtual ::grpc::Status helo(::grpc::ServerContext* context, const ::underworlds::Name* request, ::underworlds::Client* response);
    // Returns the uptime of the server, in seconds
    virtual ::grpc::Status uptime(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Time* response);
    // Returns the current topology of underworlds: the list of worlds and the
    // list of clients + their interactions with the worlds
    virtual ::grpc::Status topology(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Topology* response);
    // Hard reset of Underworlds: the whole network is deleted: worlds, clients
    // The existing mesh database is kept, however.
    virtual ::grpc::Status reset(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Empty* response);
    // NODES
    //
    // Returns the number of nodes in a given world.
    // 
    // Accepts a context (client ID and world) and returns the number of existing nodes.
    virtual ::grpc::Status getNodesLen(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Size* response);
    // Returns the list of node IDs present in the given world
    virtual ::grpc::Status getNodesIds(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Nodes* response);
    // Returns the root node ID of the given world
    virtual ::grpc::Status getRootNode(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Node* response);
    // Returns a node from its ID in the given world.
    // Note that only the node ID is used (and thus, required).
    virtual ::grpc::Status getNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Node* response);
    // Updates (and broadcasts to all client) a node in a given world
    virtual ::grpc::Status updateNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response);
    // Deletes (and broadcasts to all client) a node in a given world
    virtual ::grpc::Status deleteNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response);
    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    virtual ::grpc::Status getNodeInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::NodeInvalidation>* writer);
    // TIMELINE
    //
    // Returns the timeline origin: time of the timeline creation
    virtual ::grpc::Status timelineOrigin(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Time* response);
    // Notifies the server that an event occured
    virtual ::grpc::Status event(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response);
    // Notifies the server that a specific situation has started
    virtual ::grpc::Status startSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response);
    // Notifies the server that a specific situation has ended
    virtual ::grpc::Status endSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response);
    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    virtual ::grpc::Status getTimelineInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::TimelineInvalidation>* writer);
    // MESHES
    //
    // Returns whether the given mesh is already available on the server.
    // Note that only the mesh ID is used.
    virtual ::grpc::Status hasMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Bool* response);
    // Returns a 3D mesh.
    // Note that only the ID of the input mesh is used.
    virtual ::grpc::Status getMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Mesh* response);
    // Sends a 3D mesh to the server.
    virtual ::grpc::Status pushMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_helo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_helo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_helo() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status helo(::grpc::ServerContext* context, const ::underworlds::Name* request, ::underworlds::Client* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthelo(::grpc::ServerContext* context, ::underworlds::Name* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Client>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_uptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_uptime() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_uptime() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status uptime(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Time* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestuptime(::grpc::ServerContext* context, ::underworlds::Client* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Time>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_topology() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_topology() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status topology(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Topology* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttopology(::grpc::ServerContext* context, ::underworlds::Client* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Topology>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_reset() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_reset() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset(::grpc::ServerContext* context, ::underworlds::Client* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNodesLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getNodesLen() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_getNodesLen() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodesLen(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Size* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNodesLen(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Size>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNodesIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getNodesIds() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_getNodesIds() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodesIds(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Nodes* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNodesIds(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Nodes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRootNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getRootNode() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_getRootNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRootNode(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Node* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRootNode(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Node>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getNode() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Node* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNode(::grpc::ServerContext* context, ::underworlds::NodeInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Node>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_updateNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_updateNode() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_updateNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updateNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestupdateNode(::grpc::ServerContext* context, ::underworlds::NodeInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deleteNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deleteNode() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_deleteNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeleteNode(::grpc::ServerContext* context, ::underworlds::NodeInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNodeInvalidations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getNodeInvalidations() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getNodeInvalidations() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodeInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::NodeInvalidation>* writer) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNodeInvalidations(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncWriter< ::underworlds::NodeInvalidation>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_timelineOrigin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_timelineOrigin() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_timelineOrigin() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status timelineOrigin(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Time* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesttimelineOrigin(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Time>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_event() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_event() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status event(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestevent(::grpc::ServerContext* context, ::underworlds::SituationInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_startSituation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_startSituation() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_startSituation() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartSituation(::grpc::ServerContext* context, ::underworlds::SituationInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_endSituation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_endSituation() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_endSituation() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status endSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestendSituation(::grpc::ServerContext* context, ::underworlds::SituationInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getTimelineInvalidations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getTimelineInvalidations() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_getTimelineInvalidations() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTimelineInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::TimelineInvalidation>* writer) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetTimelineInvalidations(::grpc::ServerContext* context, ::underworlds::Context* request, ::grpc::ServerAsyncWriter< ::underworlds::TimelineInvalidation>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(15, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hasMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_hasMesh() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_hasMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Bool* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasMesh(::grpc::ServerContext* context, ::underworlds::MeshInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_getMesh() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_getMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Mesh* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMesh(::grpc::ServerContext* context, ::underworlds::MeshInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Mesh>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pushMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_pushMesh() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_pushMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pushMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpushMesh(::grpc::ServerContext* context, ::underworlds::MeshInContext* request, ::grpc::ServerAsyncResponseWriter< ::underworlds::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_helo<WithAsyncMethod_uptime<WithAsyncMethod_topology<WithAsyncMethod_reset<WithAsyncMethod_getNodesLen<WithAsyncMethod_getNodesIds<WithAsyncMethod_getRootNode<WithAsyncMethod_getNode<WithAsyncMethod_updateNode<WithAsyncMethod_deleteNode<WithAsyncMethod_getNodeInvalidations<WithAsyncMethod_timelineOrigin<WithAsyncMethod_event<WithAsyncMethod_startSituation<WithAsyncMethod_endSituation<WithAsyncMethod_getTimelineInvalidations<WithAsyncMethod_hasMesh<WithAsyncMethod_getMesh<WithAsyncMethod_pushMesh<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_helo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_helo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_helo() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status helo(::grpc::ServerContext* context, const ::underworlds::Name* request, ::underworlds::Client* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_uptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_uptime() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_uptime() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status uptime(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Time* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_topology() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_topology() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status topology(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Topology* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_reset() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_reset() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset(::grpc::ServerContext* context, const ::underworlds::Client* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNodesLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getNodesLen() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_getNodesLen() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodesLen(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Size* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNodesIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getNodesIds() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_getNodesIds() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodesIds(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Nodes* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRootNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getRootNode() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_getRootNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRootNode(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Node* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getNode() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Node* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_updateNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_updateNode() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_updateNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updateNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deleteNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deleteNode() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_deleteNode() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteNode(::grpc::ServerContext* context, const ::underworlds::NodeInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNodeInvalidations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getNodeInvalidations() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getNodeInvalidations() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNodeInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::NodeInvalidation>* writer) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_timelineOrigin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_timelineOrigin() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_timelineOrigin() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status timelineOrigin(::grpc::ServerContext* context, const ::underworlds::Context* request, ::underworlds::Time* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_event() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_event() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status event(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_startSituation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_startSituation() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_startSituation() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_endSituation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_endSituation() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_endSituation() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status endSituation(::grpc::ServerContext* context, const ::underworlds::SituationInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getTimelineInvalidations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getTimelineInvalidations() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_getTimelineInvalidations() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTimelineInvalidations(::grpc::ServerContext* context, const ::underworlds::Context* request, ::grpc::ServerWriter< ::underworlds::TimelineInvalidation>* writer) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hasMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_hasMesh() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_hasMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Bool* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_getMesh() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_getMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Mesh* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pushMesh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_pushMesh() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_pushMesh() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pushMesh(::grpc::ServerContext* context, const ::underworlds::MeshInContext* request, ::underworlds::Empty* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
};

}  // namespace underworlds


#endif  // GRPC_underworlds_2eproto__INCLUDED
