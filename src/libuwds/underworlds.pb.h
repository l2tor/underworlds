// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: underworlds.proto

#ifndef PROTOBUF_underworlds_2eproto__INCLUDED
#define PROTOBUF_underworlds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace underworlds {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_underworlds_2eproto();
void protobuf_AssignDesc_underworlds_2eproto();
void protobuf_ShutdownFile_underworlds_2eproto();

class Bool;
class Client;
class ClientInteraction;
class Color;
class Context;
class Empty;
class Mesh;
class MeshInContext;
class Name;
class Node;
class NodeInContext;
class NodeInvalidation;
class Nodes;
class Point;
class Pointf;
class Situation;
class SituationInContext;
class Size;
class Time;
class TimelineInvalidation;
class Topology;

enum ClientInteraction_InteractionType {
  ClientInteraction_InteractionType_READER = 0,
  ClientInteraction_InteractionType_PROVIDER = 1,
  ClientInteraction_InteractionType_MONITOR = 2,
  ClientInteraction_InteractionType_FILTER = 3,
  ClientInteraction_InteractionType_ClientInteraction_InteractionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClientInteraction_InteractionType_ClientInteraction_InteractionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClientInteraction_InteractionType_IsValid(int value);
const ClientInteraction_InteractionType ClientInteraction_InteractionType_InteractionType_MIN = ClientInteraction_InteractionType_READER;
const ClientInteraction_InteractionType ClientInteraction_InteractionType_InteractionType_MAX = ClientInteraction_InteractionType_FILTER;
const int ClientInteraction_InteractionType_InteractionType_ARRAYSIZE = ClientInteraction_InteractionType_InteractionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientInteraction_InteractionType_descriptor();
inline const ::std::string& ClientInteraction_InteractionType_Name(ClientInteraction_InteractionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientInteraction_InteractionType_descriptor(), value);
}
inline bool ClientInteraction_InteractionType_Parse(
    const ::std::string& name, ClientInteraction_InteractionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientInteraction_InteractionType>(
    ClientInteraction_InteractionType_descriptor(), name, value);
}
enum Node_NodeType {
  Node_NodeType_UNDEFINED = 0,
  Node_NodeType_ENTITY = 1,
  Node_NodeType_MESH = 2,
  Node_NodeType_CAMERA = 3,
  Node_NodeType_Node_NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Node_NodeType_Node_NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Node_NodeType_IsValid(int value);
const Node_NodeType Node_NodeType_NodeType_MIN = Node_NodeType_UNDEFINED;
const Node_NodeType Node_NodeType_NodeType_MAX = Node_NodeType_CAMERA;
const int Node_NodeType_NodeType_ARRAYSIZE = Node_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Node_NodeType_descriptor();
inline const ::std::string& Node_NodeType_Name(Node_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Node_NodeType_descriptor(), value);
}
inline bool Node_NodeType_Parse(
    const ::std::string& name, Node_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Node_NodeType>(
    Node_NodeType_descriptor(), name, value);
}
enum NodeInvalidation_NodeInvalidationType {
  NodeInvalidation_NodeInvalidationType_NEW = 0,
  NodeInvalidation_NodeInvalidationType_UPDATE = 1,
  NodeInvalidation_NodeInvalidationType_DELETE = 2,
  NodeInvalidation_NodeInvalidationType_NodeInvalidation_NodeInvalidationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NodeInvalidation_NodeInvalidationType_NodeInvalidation_NodeInvalidationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NodeInvalidation_NodeInvalidationType_IsValid(int value);
const NodeInvalidation_NodeInvalidationType NodeInvalidation_NodeInvalidationType_NodeInvalidationType_MIN = NodeInvalidation_NodeInvalidationType_NEW;
const NodeInvalidation_NodeInvalidationType NodeInvalidation_NodeInvalidationType_NodeInvalidationType_MAX = NodeInvalidation_NodeInvalidationType_DELETE;
const int NodeInvalidation_NodeInvalidationType_NodeInvalidationType_ARRAYSIZE = NodeInvalidation_NodeInvalidationType_NodeInvalidationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeInvalidation_NodeInvalidationType_descriptor();
inline const ::std::string& NodeInvalidation_NodeInvalidationType_Name(NodeInvalidation_NodeInvalidationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeInvalidation_NodeInvalidationType_descriptor(), value);
}
inline bool NodeInvalidation_NodeInvalidationType_Parse(
    const ::std::string& name, NodeInvalidation_NodeInvalidationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeInvalidation_NodeInvalidationType>(
    NodeInvalidation_NodeInvalidationType_descriptor(), name, value);
}
enum Situation_SituationType {
  Situation_SituationType_GENERIC = 0,
  Situation_SituationType_MOTION = 1,
  Situation_SituationType_EVT_MODELLOAD = 2,
  Situation_SituationType_Situation_SituationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Situation_SituationType_Situation_SituationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Situation_SituationType_IsValid(int value);
const Situation_SituationType Situation_SituationType_SituationType_MIN = Situation_SituationType_GENERIC;
const Situation_SituationType Situation_SituationType_SituationType_MAX = Situation_SituationType_EVT_MODELLOAD;
const int Situation_SituationType_SituationType_ARRAYSIZE = Situation_SituationType_SituationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Situation_SituationType_descriptor();
inline const ::std::string& Situation_SituationType_Name(Situation_SituationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Situation_SituationType_descriptor(), value);
}
inline bool Situation_SituationType_Parse(
    const ::std::string& name, Situation_SituationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Situation_SituationType>(
    Situation_SituationType_descriptor(), name, value);
}
enum TimelineInvalidation_TimelineInvalidationType {
  TimelineInvalidation_TimelineInvalidationType_EVENT = 0,
  TimelineInvalidation_TimelineInvalidationType_START = 1,
  TimelineInvalidation_TimelineInvalidationType_END = 2,
  TimelineInvalidation_TimelineInvalidationType_TimelineInvalidation_TimelineInvalidationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TimelineInvalidation_TimelineInvalidationType_TimelineInvalidation_TimelineInvalidationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TimelineInvalidation_TimelineInvalidationType_IsValid(int value);
const TimelineInvalidation_TimelineInvalidationType TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_MIN = TimelineInvalidation_TimelineInvalidationType_EVENT;
const TimelineInvalidation_TimelineInvalidationType TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_MAX = TimelineInvalidation_TimelineInvalidationType_END;
const int TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_ARRAYSIZE = TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimelineInvalidation_TimelineInvalidationType_descriptor();
inline const ::std::string& TimelineInvalidation_TimelineInvalidationType_Name(TimelineInvalidation_TimelineInvalidationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimelineInvalidation_TimelineInvalidationType_descriptor(), value);
}
inline bool TimelineInvalidation_TimelineInvalidationType_Parse(
    const ::std::string& name, TimelineInvalidation_TimelineInvalidationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimelineInvalidation_TimelineInvalidationType>(
    TimelineInvalidation_TimelineInvalidationType_descriptor(), name, value);
}
// ===================================================================

class Empty : public ::google::protobuf::Message {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  void Swap(Empty* other);

  // implements Message ----------------------------------------------

  inline Empty* New() const { return New(NULL); }

  Empty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:underworlds.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Empty* default_instance_;
};
// -------------------------------------------------------------------

class Bool : public ::google::protobuf::Message {
 public:
  Bool();
  virtual ~Bool();

  Bool(const Bool& from);

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bool& default_instance();

  void Swap(Bool* other);

  // implements Message ----------------------------------------------

  inline Bool* New() const { return New(NULL); }

  Bool* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bool& from);
  void MergeFrom(const Bool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:underworlds.Bool)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Bool* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  inline Time* New() const { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:underworlds.Time)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double time_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class Name : public ::google::protobuf::Message {
 public:
  Name();
  virtual ~Name();

  Name(const Name& from);

  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Name& default_instance();

  void Swap(Name* other);

  // implements Message ----------------------------------------------

  inline Name* New() const { return New(NULL); }

  Name* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Name& from);
  void MergeFrom(const Name& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Name* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:underworlds.Name)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Name* default_instance_;
};
// -------------------------------------------------------------------

class Size : public ::google::protobuf::Message {
 public:
  Size();
  virtual ~Size();

  Size(const Size& from);

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Size& default_instance();

  void Swap(Size* other);

  // implements Message ----------------------------------------------

  inline Size* New() const { return New(NULL); }

  Size* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Size* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 size = 1;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:underworlds.Size)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Size* default_instance_;
};
// -------------------------------------------------------------------

class Pointf : public ::google::protobuf::Message {
 public:
  Pointf();
  virtual ~Pointf();

  Pointf(const Pointf& from);

  inline Pointf& operator=(const Pointf& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pointf& default_instance();

  void Swap(Pointf* other);

  // implements Message ----------------------------------------------

  inline Pointf* New() const { return New(NULL); }

  Pointf* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pointf& from);
  void MergeFrom(const Pointf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pointf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:underworlds.Pointf)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Pointf* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional sint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional sint32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:underworlds.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::Message {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  void Swap(Color* other);

  // implements Message ----------------------------------------------

  inline Color* New() const { return New(NULL); }

  Color* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float r = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // optional float g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // optional float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // optional float a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  float a() const;
  void set_a(float value);

  // @@protoc_insertion_point(class_scope:underworlds.Color)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Client : public ::google::protobuf::Message {
 public:
  Client();
  virtual ~Client();

  Client(const Client& from);

  inline Client& operator=(const Client& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Client& default_instance();

  void Swap(Client* other);

  // implements Message ----------------------------------------------

  inline Client* New() const { return New(NULL); }

  Client* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Client& from);
  void MergeFrom(const Client& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Client* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .underworlds.ClientInteraction links = 3;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 3;
  const ::underworlds::ClientInteraction& links(int index) const;
  ::underworlds::ClientInteraction* mutable_links(int index);
  ::underworlds::ClientInteraction* add_links();
  ::google::protobuf::RepeatedPtrField< ::underworlds::ClientInteraction >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::ClientInteraction >&
      links() const;

  // @@protoc_insertion_point(class_scope:underworlds.Client)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::ClientInteraction > links_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Client* default_instance_;
};
// -------------------------------------------------------------------

class ClientInteraction : public ::google::protobuf::Message {
 public:
  ClientInteraction();
  virtual ~ClientInteraction();

  ClientInteraction(const ClientInteraction& from);

  inline ClientInteraction& operator=(const ClientInteraction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInteraction& default_instance();

  void Swap(ClientInteraction* other);

  // implements Message ----------------------------------------------

  inline ClientInteraction* New() const { return New(NULL); }

  ClientInteraction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientInteraction& from);
  void MergeFrom(const ClientInteraction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientInteraction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientInteraction_InteractionType InteractionType;
  static const InteractionType READER =
    ClientInteraction_InteractionType_READER;
  static const InteractionType PROVIDER =
    ClientInteraction_InteractionType_PROVIDER;
  static const InteractionType MONITOR =
    ClientInteraction_InteractionType_MONITOR;
  static const InteractionType FILTER =
    ClientInteraction_InteractionType_FILTER;
  static inline bool InteractionType_IsValid(int value) {
    return ClientInteraction_InteractionType_IsValid(value);
  }
  static const InteractionType InteractionType_MIN =
    ClientInteraction_InteractionType_InteractionType_MIN;
  static const InteractionType InteractionType_MAX =
    ClientInteraction_InteractionType_InteractionType_MAX;
  static const int InteractionType_ARRAYSIZE =
    ClientInteraction_InteractionType_InteractionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InteractionType_descriptor() {
    return ClientInteraction_InteractionType_descriptor();
  }
  static inline const ::std::string& InteractionType_Name(InteractionType value) {
    return ClientInteraction_InteractionType_Name(value);
  }
  static inline bool InteractionType_Parse(const ::std::string& name,
      InteractionType* value) {
    return ClientInteraction_InteractionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string world = 1;
  void clear_world();
  static const int kWorldFieldNumber = 1;
  const ::std::string& world() const;
  void set_world(const ::std::string& value);
  void set_world(const char* value);
  void set_world(const char* value, size_t size);
  ::std::string* mutable_world();
  ::std::string* release_world();
  void set_allocated_world(::std::string* world);

  // optional .underworlds.ClientInteraction.InteractionType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::underworlds::ClientInteraction_InteractionType type() const;
  void set_type(::underworlds::ClientInteraction_InteractionType value);

  // optional .underworlds.Time last_activity = 3;
  bool has_last_activity() const;
  void clear_last_activity();
  static const int kLastActivityFieldNumber = 3;
  const ::underworlds::Time& last_activity() const;
  ::underworlds::Time* mutable_last_activity();
  ::underworlds::Time* release_last_activity();
  void set_allocated_last_activity(::underworlds::Time* last_activity);

  // @@protoc_insertion_point(class_scope:underworlds.ClientInteraction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr world_;
  ::underworlds::Time* last_activity_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static ClientInteraction* default_instance_;
};
// -------------------------------------------------------------------

class Context : public ::google::protobuf::Message {
 public:
  Context();
  virtual ~Context();

  Context(const Context& from);

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Context& default_instance();

  void Swap(Context* other);

  // implements Message ----------------------------------------------

  inline Context* New() const { return New(NULL); }

  Context* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Context* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client = 1;
  void clear_client();
  static const int kClientFieldNumber = 1;
  const ::std::string& client() const;
  void set_client(const ::std::string& value);
  void set_client(const char* value);
  void set_client(const char* value, size_t size);
  ::std::string* mutable_client();
  ::std::string* release_client();
  void set_allocated_client(::std::string* client);

  // optional string world = 2;
  void clear_world();
  static const int kWorldFieldNumber = 2;
  const ::std::string& world() const;
  void set_world(const ::std::string& value);
  void set_world(const char* value);
  void set_world(const char* value, size_t size);
  ::std::string* mutable_world();
  ::std::string* release_world();
  void set_allocated_world(::std::string* world);

  // @@protoc_insertion_point(class_scope:underworlds.Context)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr client_;
  ::google::protobuf::internal::ArenaStringPtr world_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Context* default_instance_;
};
// -------------------------------------------------------------------

class Topology : public ::google::protobuf::Message {
 public:
  Topology();
  virtual ~Topology();

  Topology(const Topology& from);

  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Topology& default_instance();

  void Swap(Topology* other);

  // implements Message ----------------------------------------------

  inline Topology* New() const { return New(NULL); }

  Topology* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Topology& from);
  void MergeFrom(const Topology& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Topology* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string worlds = 1;
  int worlds_size() const;
  void clear_worlds();
  static const int kWorldsFieldNumber = 1;
  const ::std::string& worlds(int index) const;
  ::std::string* mutable_worlds(int index);
  void set_worlds(int index, const ::std::string& value);
  void set_worlds(int index, const char* value);
  void set_worlds(int index, const char* value, size_t size);
  ::std::string* add_worlds();
  void add_worlds(const ::std::string& value);
  void add_worlds(const char* value);
  void add_worlds(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worlds() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worlds();

  // repeated .underworlds.Client clients = 2;
  int clients_size() const;
  void clear_clients();
  static const int kClientsFieldNumber = 2;
  const ::underworlds::Client& clients(int index) const;
  ::underworlds::Client* mutable_clients(int index);
  ::underworlds::Client* add_clients();
  ::google::protobuf::RepeatedPtrField< ::underworlds::Client >*
      mutable_clients();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::Client >&
      clients() const;

  // @@protoc_insertion_point(class_scope:underworlds.Topology)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worlds_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::Client > clients_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Topology* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Node_NodeType NodeType;
  static const NodeType UNDEFINED =
    Node_NodeType_UNDEFINED;
  static const NodeType ENTITY =
    Node_NodeType_ENTITY;
  static const NodeType MESH =
    Node_NodeType_MESH;
  static const NodeType CAMERA =
    Node_NodeType_CAMERA;
  static inline bool NodeType_IsValid(int value) {
    return Node_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    Node_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    Node_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    Node_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return Node_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return Node_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return Node_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .underworlds.Node.NodeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::underworlds::Node_NodeType type() const;
  void set_type(::underworlds::Node_NodeType value);

  // optional string parent = 4;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  const ::std::string& parent() const;
  void set_parent(const ::std::string& value);
  void set_parent(const char* value);
  void set_parent(const char* value, size_t size);
  ::std::string* mutable_parent();
  ::std::string* release_parent();
  void set_allocated_parent(::std::string* parent);

  // repeated string children = 5;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 5;
  const ::std::string& children(int index) const;
  ::std::string* mutable_children(int index);
  void set_children(int index, const ::std::string& value);
  void set_children(int index, const char* value);
  void set_children(int index, const char* value, size_t size);
  ::std::string* add_children();
  void add_children(const ::std::string& value);
  void add_children(const char* value);
  void add_children(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& children() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_children();

  // repeated float transformation = 6;
  int transformation_size() const;
  void clear_transformation();
  static const int kTransformationFieldNumber = 6;
  float transformation(int index) const;
  void set_transformation(int index, float value);
  void add_transformation(float value);
  const ::google::protobuf::RepeatedField< float >&
      transformation() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_transformation();

  // optional double last_update = 8;
  void clear_last_update();
  static const int kLastUpdateFieldNumber = 8;
  double last_update() const;
  void set_last_update(double value);

  // repeated string lowres = 16;
  int lowres_size() const;
  void clear_lowres();
  static const int kLowresFieldNumber = 16;
  const ::std::string& lowres(int index) const;
  ::std::string* mutable_lowres(int index);
  void set_lowres(int index, const ::std::string& value);
  void set_lowres(int index, const char* value);
  void set_lowres(int index, const char* value, size_t size);
  ::std::string* add_lowres();
  void add_lowres(const ::std::string& value);
  void add_lowres(const char* value);
  void add_lowres(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lowres() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lowres();

  // repeated string hires = 17;
  int hires_size() const;
  void clear_hires();
  static const int kHiresFieldNumber = 17;
  const ::std::string& hires(int index) const;
  ::std::string* mutable_hires(int index);
  void set_hires(int index, const ::std::string& value);
  void set_hires(int index, const char* value);
  void set_hires(int index, const char* value, size_t size);
  ::std::string* add_hires();
  void add_hires(const ::std::string& value);
  void add_hires(const char* value);
  void add_hires(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& hires() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hires();

  // repeated string cad = 18;
  int cad_size() const;
  void clear_cad();
  static const int kCadFieldNumber = 18;
  const ::std::string& cad(int index) const;
  ::std::string* mutable_cad(int index);
  void set_cad(int index, const ::std::string& value);
  void set_cad(int index, const char* value);
  void set_cad(int index, const char* value, size_t size);
  ::std::string* add_cad();
  void add_cad(const ::std::string& value);
  void add_cad(const char* value);
  void add_cad(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cad() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cad();

  // repeated .underworlds.Pointf aabb = 19;
  int aabb_size() const;
  void clear_aabb();
  static const int kAabbFieldNumber = 19;
  const ::underworlds::Pointf& aabb(int index) const;
  ::underworlds::Pointf* mutable_aabb(int index);
  ::underworlds::Pointf* add_aabb();
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
      mutable_aabb();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
      aabb() const;

  // optional bool physics = 30;
  void clear_physics();
  static const int kPhysicsFieldNumber = 30;
  bool physics() const;
  void set_physics(bool value);

  // optional float clipplanenear = 40;
  void clear_clipplanenear();
  static const int kClipplanenearFieldNumber = 40;
  float clipplanenear() const;
  void set_clipplanenear(float value);

  // optional float clipplanefar = 41;
  void clear_clipplanefar();
  static const int kClipplanefarFieldNumber = 41;
  float clipplanefar() const;
  void set_clipplanefar(float value);

  // optional float aspect = 42;
  void clear_aspect();
  static const int kAspectFieldNumber = 42;
  float aspect() const;
  void set_aspect(float value);

  // optional float horizontalfov = 43;
  void clear_horizontalfov();
  static const int kHorizontalfovFieldNumber = 43;
  float horizontalfov() const;
  void set_horizontalfov(float value);

  // @@protoc_insertion_point(class_scope:underworlds.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr parent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> children_;
  ::google::protobuf::RepeatedField< float > transformation_;
  mutable int _transformation_cached_byte_size_;
  double last_update_;
  int type_;
  bool physics_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lowres_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hires_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cad_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf > aabb_;
  float clipplanenear_;
  float clipplanefar_;
  float aspect_;
  float horizontalfov_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Nodes : public ::google::protobuf::Message {
 public:
  Nodes();
  virtual ~Nodes();

  Nodes(const Nodes& from);

  inline Nodes& operator=(const Nodes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nodes& default_instance();

  void Swap(Nodes* other);

  // implements Message ----------------------------------------------

  inline Nodes* New() const { return New(NULL); }

  Nodes* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nodes& from);
  void MergeFrom(const Nodes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Nodes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // @@protoc_insertion_point(class_scope:underworlds.Nodes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Nodes* default_instance_;
};
// -------------------------------------------------------------------

class NodeInContext : public ::google::protobuf::Message {
 public:
  NodeInContext();
  virtual ~NodeInContext();

  NodeInContext(const NodeInContext& from);

  inline NodeInContext& operator=(const NodeInContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInContext& default_instance();

  void Swap(NodeInContext* other);

  // implements Message ----------------------------------------------

  inline NodeInContext* New() const { return New(NULL); }

  NodeInContext* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInContext& from);
  void MergeFrom(const NodeInContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeInContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .underworlds.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::underworlds::Context& context() const;
  ::underworlds::Context* mutable_context();
  ::underworlds::Context* release_context();
  void set_allocated_context(::underworlds::Context* context);

  // optional .underworlds.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::underworlds::Node& node() const;
  ::underworlds::Node* mutable_node();
  ::underworlds::Node* release_node();
  void set_allocated_node(::underworlds::Node* node);

  // @@protoc_insertion_point(class_scope:underworlds.NodeInContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::underworlds::Context* context_;
  ::underworlds::Node* node_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static NodeInContext* default_instance_;
};
// -------------------------------------------------------------------

class NodeInvalidation : public ::google::protobuf::Message {
 public:
  NodeInvalidation();
  virtual ~NodeInvalidation();

  NodeInvalidation(const NodeInvalidation& from);

  inline NodeInvalidation& operator=(const NodeInvalidation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInvalidation& default_instance();

  void Swap(NodeInvalidation* other);

  // implements Message ----------------------------------------------

  inline NodeInvalidation* New() const { return New(NULL); }

  NodeInvalidation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInvalidation& from);
  void MergeFrom(const NodeInvalidation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeInvalidation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeInvalidation_NodeInvalidationType NodeInvalidationType;
  static const NodeInvalidationType NEW =
    NodeInvalidation_NodeInvalidationType_NEW;
  static const NodeInvalidationType UPDATE =
    NodeInvalidation_NodeInvalidationType_UPDATE;
  static const NodeInvalidationType DELETE =
    NodeInvalidation_NodeInvalidationType_DELETE;
  static inline bool NodeInvalidationType_IsValid(int value) {
    return NodeInvalidation_NodeInvalidationType_IsValid(value);
  }
  static const NodeInvalidationType NodeInvalidationType_MIN =
    NodeInvalidation_NodeInvalidationType_NodeInvalidationType_MIN;
  static const NodeInvalidationType NodeInvalidationType_MAX =
    NodeInvalidation_NodeInvalidationType_NodeInvalidationType_MAX;
  static const int NodeInvalidationType_ARRAYSIZE =
    NodeInvalidation_NodeInvalidationType_NodeInvalidationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeInvalidationType_descriptor() {
    return NodeInvalidation_NodeInvalidationType_descriptor();
  }
  static inline const ::std::string& NodeInvalidationType_Name(NodeInvalidationType value) {
    return NodeInvalidation_NodeInvalidationType_Name(value);
  }
  static inline bool NodeInvalidationType_Parse(const ::std::string& name,
      NodeInvalidationType* value) {
    return NodeInvalidation_NodeInvalidationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .underworlds.NodeInvalidation.NodeInvalidationType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::underworlds::NodeInvalidation_NodeInvalidationType type() const;
  void set_type(::underworlds::NodeInvalidation_NodeInvalidationType value);

  // optional string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:underworlds.NodeInvalidation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static NodeInvalidation* default_instance_;
};
// -------------------------------------------------------------------

class Situation : public ::google::protobuf::Message {
 public:
  Situation();
  virtual ~Situation();

  Situation(const Situation& from);

  inline Situation& operator=(const Situation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Situation& default_instance();

  void Swap(Situation* other);

  // implements Message ----------------------------------------------

  inline Situation* New() const { return New(NULL); }

  Situation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Situation& from);
  void MergeFrom(const Situation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Situation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Situation_SituationType SituationType;
  static const SituationType GENERIC =
    Situation_SituationType_GENERIC;
  static const SituationType MOTION =
    Situation_SituationType_MOTION;
  static const SituationType EVT_MODELLOAD =
    Situation_SituationType_EVT_MODELLOAD;
  static inline bool SituationType_IsValid(int value) {
    return Situation_SituationType_IsValid(value);
  }
  static const SituationType SituationType_MIN =
    Situation_SituationType_SituationType_MIN;
  static const SituationType SituationType_MAX =
    Situation_SituationType_SituationType_MAX;
  static const int SituationType_ARRAYSIZE =
    Situation_SituationType_SituationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SituationType_descriptor() {
    return Situation_SituationType_descriptor();
  }
  static inline const ::std::string& SituationType_Name(SituationType value) {
    return Situation_SituationType_Name(value);
  }
  static inline bool SituationType_Parse(const ::std::string& name,
      SituationType* value) {
    return Situation_SituationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .underworlds.Situation.SituationType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::underworlds::Situation_SituationType type() const;
  void set_type(::underworlds::Situation_SituationType value);

  // optional string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional .underworlds.Time start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  const ::underworlds::Time& start() const;
  ::underworlds::Time* mutable_start();
  ::underworlds::Time* release_start();
  void set_allocated_start(::underworlds::Time* start);

  // optional .underworlds.Time end = 5;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 5;
  const ::underworlds::Time& end() const;
  ::underworlds::Time* mutable_end();
  ::underworlds::Time* release_end();
  void set_allocated_end(::underworlds::Time* end);

  // @@protoc_insertion_point(class_scope:underworlds.Situation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::underworlds::Time* start_;
  ::underworlds::Time* end_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Situation* default_instance_;
};
// -------------------------------------------------------------------

class SituationInContext : public ::google::protobuf::Message {
 public:
  SituationInContext();
  virtual ~SituationInContext();

  SituationInContext(const SituationInContext& from);

  inline SituationInContext& operator=(const SituationInContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SituationInContext& default_instance();

  void Swap(SituationInContext* other);

  // implements Message ----------------------------------------------

  inline SituationInContext* New() const { return New(NULL); }

  SituationInContext* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SituationInContext& from);
  void MergeFrom(const SituationInContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SituationInContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .underworlds.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::underworlds::Context& context() const;
  ::underworlds::Context* mutable_context();
  ::underworlds::Context* release_context();
  void set_allocated_context(::underworlds::Context* context);

  // optional .underworlds.Situation situation = 2;
  bool has_situation() const;
  void clear_situation();
  static const int kSituationFieldNumber = 2;
  const ::underworlds::Situation& situation() const;
  ::underworlds::Situation* mutable_situation();
  ::underworlds::Situation* release_situation();
  void set_allocated_situation(::underworlds::Situation* situation);

  // @@protoc_insertion_point(class_scope:underworlds.SituationInContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::underworlds::Context* context_;
  ::underworlds::Situation* situation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static SituationInContext* default_instance_;
};
// -------------------------------------------------------------------

class TimelineInvalidation : public ::google::protobuf::Message {
 public:
  TimelineInvalidation();
  virtual ~TimelineInvalidation();

  TimelineInvalidation(const TimelineInvalidation& from);

  inline TimelineInvalidation& operator=(const TimelineInvalidation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimelineInvalidation& default_instance();

  void Swap(TimelineInvalidation* other);

  // implements Message ----------------------------------------------

  inline TimelineInvalidation* New() const { return New(NULL); }

  TimelineInvalidation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimelineInvalidation& from);
  void MergeFrom(const TimelineInvalidation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimelineInvalidation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TimelineInvalidation_TimelineInvalidationType TimelineInvalidationType;
  static const TimelineInvalidationType EVENT =
    TimelineInvalidation_TimelineInvalidationType_EVENT;
  static const TimelineInvalidationType START =
    TimelineInvalidation_TimelineInvalidationType_START;
  static const TimelineInvalidationType END =
    TimelineInvalidation_TimelineInvalidationType_END;
  static inline bool TimelineInvalidationType_IsValid(int value) {
    return TimelineInvalidation_TimelineInvalidationType_IsValid(value);
  }
  static const TimelineInvalidationType TimelineInvalidationType_MIN =
    TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_MIN;
  static const TimelineInvalidationType TimelineInvalidationType_MAX =
    TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_MAX;
  static const int TimelineInvalidationType_ARRAYSIZE =
    TimelineInvalidation_TimelineInvalidationType_TimelineInvalidationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimelineInvalidationType_descriptor() {
    return TimelineInvalidation_TimelineInvalidationType_descriptor();
  }
  static inline const ::std::string& TimelineInvalidationType_Name(TimelineInvalidationType value) {
    return TimelineInvalidation_TimelineInvalidationType_Name(value);
  }
  static inline bool TimelineInvalidationType_Parse(const ::std::string& name,
      TimelineInvalidationType* value) {
    return TimelineInvalidation_TimelineInvalidationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .underworlds.TimelineInvalidation.TimelineInvalidationType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::underworlds::TimelineInvalidation_TimelineInvalidationType type() const;
  void set_type(::underworlds::TimelineInvalidation_TimelineInvalidationType value);

  // optional string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:underworlds.TimelineInvalidation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static TimelineInvalidation* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh& default_instance();

  void Swap(Mesh* other);

  // implements Message ----------------------------------------------

  inline Mesh* New() const { return New(NULL); }

  Mesh* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // repeated .underworlds.Pointf vertices = 2;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 2;
  const ::underworlds::Pointf& vertices(int index) const;
  ::underworlds::Pointf* mutable_vertices(int index);
  ::underworlds::Pointf* add_vertices();
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
      mutable_vertices();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
      vertices() const;

  // repeated .underworlds.Point faces = 3;
  int faces_size() const;
  void clear_faces();
  static const int kFacesFieldNumber = 3;
  const ::underworlds::Point& faces(int index) const;
  ::underworlds::Point* mutable_faces(int index);
  ::underworlds::Point* add_faces();
  ::google::protobuf::RepeatedPtrField< ::underworlds::Point >*
      mutable_faces();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::Point >&
      faces() const;

  // repeated .underworlds.Pointf normals = 4;
  int normals_size() const;
  void clear_normals();
  static const int kNormalsFieldNumber = 4;
  const ::underworlds::Pointf& normals(int index) const;
  ::underworlds::Pointf* mutable_normals(int index);
  ::underworlds::Pointf* add_normals();
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
      mutable_normals();
  const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
      normals() const;

  // repeated uint32 colors = 5;
  int colors_size() const;
  void clear_colors();
  static const int kColorsFieldNumber = 5;
  ::google::protobuf::uint32 colors(int index) const;
  void set_colors(int index, ::google::protobuf::uint32 value);
  void add_colors(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      colors() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_colors();

  // optional .underworlds.Color diffuse = 6;
  bool has_diffuse() const;
  void clear_diffuse();
  static const int kDiffuseFieldNumber = 6;
  const ::underworlds::Color& diffuse() const;
  ::underworlds::Color* mutable_diffuse();
  ::underworlds::Color* release_diffuse();
  void set_allocated_diffuse(::underworlds::Color* diffuse);

  // @@protoc_insertion_point(class_scope:underworlds.Mesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf > vertices_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::Point > faces_;
  ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf > normals_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > colors_;
  mutable int _colors_cached_byte_size_;
  ::underworlds::Color* diffuse_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class MeshInContext : public ::google::protobuf::Message {
 public:
  MeshInContext();
  virtual ~MeshInContext();

  MeshInContext(const MeshInContext& from);

  inline MeshInContext& operator=(const MeshInContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshInContext& default_instance();

  void Swap(MeshInContext* other);

  // implements Message ----------------------------------------------

  inline MeshInContext* New() const { return New(NULL); }

  MeshInContext* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MeshInContext& from);
  void MergeFrom(const MeshInContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MeshInContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .underworlds.Client client = 1;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 1;
  const ::underworlds::Client& client() const;
  ::underworlds::Client* mutable_client();
  ::underworlds::Client* release_client();
  void set_allocated_client(::underworlds::Client* client);

  // optional .underworlds.Mesh mesh = 2;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 2;
  const ::underworlds::Mesh& mesh() const;
  ::underworlds::Mesh* mutable_mesh();
  ::underworlds::Mesh* release_mesh();
  void set_allocated_mesh(::underworlds::Mesh* mesh);

  // @@protoc_insertion_point(class_scope:underworlds.MeshInContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::underworlds::Client* client_;
  ::underworlds::Mesh* mesh_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_underworlds_2eproto();
  friend void protobuf_AssignDesc_underworlds_2eproto();
  friend void protobuf_ShutdownFile_underworlds_2eproto();

  void InitAsDefaultInstance();
  static MeshInContext* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Empty

// -------------------------------------------------------------------

// Bool

// optional bool value = 1;
inline void Bool::clear_value() {
  value_ = false;
}
inline bool Bool::value() const {
  // @@protoc_insertion_point(field_get:underworlds.Bool.value)
  return value_;
}
inline void Bool::set_value(bool value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Bool.value)
}

// -------------------------------------------------------------------

// Time

// optional double time = 1;
inline void Time::clear_time() {
  time_ = 0;
}
inline double Time::time() const {
  // @@protoc_insertion_point(field_get:underworlds.Time.time)
  return time_;
}
inline void Time::set_time(double value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Time.time)
}

// -------------------------------------------------------------------

// Name

// optional string name = 1;
inline void Name::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Name::name() const {
  // @@protoc_insertion_point(field_get:underworlds.Name.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Name::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Name.name)
}
inline void Name::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Name.name)
}
inline void Name::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Name.name)
}
inline ::std::string* Name::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Name.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Name::release_name() {
  // @@protoc_insertion_point(field_release:underworlds.Name.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Name::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Name.name)
}

// -------------------------------------------------------------------

// Size

// optional int32 size = 1;
inline void Size::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 Size::size() const {
  // @@protoc_insertion_point(field_get:underworlds.Size.size)
  return size_;
}
inline void Size::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Size.size)
}

// -------------------------------------------------------------------

// Pointf

// optional float x = 1;
inline void Pointf::clear_x() {
  x_ = 0;
}
inline float Pointf::x() const {
  // @@protoc_insertion_point(field_get:underworlds.Pointf.x)
  return x_;
}
inline void Pointf::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Pointf.x)
}

// optional float y = 2;
inline void Pointf::clear_y() {
  y_ = 0;
}
inline float Pointf::y() const {
  // @@protoc_insertion_point(field_get:underworlds.Pointf.y)
  return y_;
}
inline void Pointf::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Pointf.y)
}

// optional float z = 3;
inline void Pointf::clear_z() {
  z_ = 0;
}
inline float Pointf::z() const {
  // @@protoc_insertion_point(field_get:underworlds.Pointf.z)
  return z_;
}
inline void Pointf::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Pointf.z)
}

// -------------------------------------------------------------------

// Point

// optional sint32 x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Point::x() const {
  // @@protoc_insertion_point(field_get:underworlds.Point.x)
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Point.x)
}

// optional sint32 y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Point::y() const {
  // @@protoc_insertion_point(field_get:underworlds.Point.y)
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Point.y)
}

// optional sint32 z = 3;
inline void Point::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Point::z() const {
  // @@protoc_insertion_point(field_get:underworlds.Point.z)
  return z_;
}
inline void Point::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Point.z)
}

// -------------------------------------------------------------------

// Color

// optional float r = 1;
inline void Color::clear_r() {
  r_ = 0;
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:underworlds.Color.r)
  return r_;
}
inline void Color::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Color.r)
}

// optional float g = 2;
inline void Color::clear_g() {
  g_ = 0;
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:underworlds.Color.g)
  return g_;
}
inline void Color::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Color.g)
}

// optional float b = 3;
inline void Color::clear_b() {
  b_ = 0;
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:underworlds.Color.b)
  return b_;
}
inline void Color::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Color.b)
}

// optional float a = 4;
inline void Color::clear_a() {
  a_ = 0;
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:underworlds.Color.a)
  return a_;
}
inline void Color::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Color.a)
}

// -------------------------------------------------------------------

// Client

// optional string id = 1;
inline void Client::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Client::id() const {
  // @@protoc_insertion_point(field_get:underworlds.Client.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Client::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Client.id)
}
inline void Client::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Client.id)
}
inline void Client::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Client.id)
}
inline ::std::string* Client::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Client.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Client::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.Client.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Client::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Client.id)
}

// optional string name = 2;
inline void Client::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Client::name() const {
  // @@protoc_insertion_point(field_get:underworlds.Client.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Client::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Client.name)
}
inline void Client::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Client.name)
}
inline void Client::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Client.name)
}
inline ::std::string* Client::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Client.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Client::release_name() {
  // @@protoc_insertion_point(field_release:underworlds.Client.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Client::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Client.name)
}

// repeated .underworlds.ClientInteraction links = 3;
inline int Client::links_size() const {
  return links_.size();
}
inline void Client::clear_links() {
  links_.Clear();
}
inline const ::underworlds::ClientInteraction& Client::links(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Client.links)
  return links_.Get(index);
}
inline ::underworlds::ClientInteraction* Client::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Client.links)
  return links_.Mutable(index);
}
inline ::underworlds::ClientInteraction* Client::add_links() {
  // @@protoc_insertion_point(field_add:underworlds.Client.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::ClientInteraction >*
Client::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Client.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::ClientInteraction >&
Client::links() const {
  // @@protoc_insertion_point(field_list:underworlds.Client.links)
  return links_;
}

// -------------------------------------------------------------------

// ClientInteraction

// optional string world = 1;
inline void ClientInteraction::clear_world() {
  world_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientInteraction::world() const {
  // @@protoc_insertion_point(field_get:underworlds.ClientInteraction.world)
  return world_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInteraction::set_world(const ::std::string& value) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.ClientInteraction.world)
}
inline void ClientInteraction::set_world(const char* value) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.ClientInteraction.world)
}
inline void ClientInteraction::set_world(const char* value, size_t size) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.ClientInteraction.world)
}
inline ::std::string* ClientInteraction::mutable_world() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.ClientInteraction.world)
  return world_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientInteraction::release_world() {
  // @@protoc_insertion_point(field_release:underworlds.ClientInteraction.world)
  
  return world_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInteraction::set_allocated_world(::std::string* world) {
  if (world != NULL) {
    
  } else {
    
  }
  world_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), world);
  // @@protoc_insertion_point(field_set_allocated:underworlds.ClientInteraction.world)
}

// optional .underworlds.ClientInteraction.InteractionType type = 2;
inline void ClientInteraction::clear_type() {
  type_ = 0;
}
inline ::underworlds::ClientInteraction_InteractionType ClientInteraction::type() const {
  // @@protoc_insertion_point(field_get:underworlds.ClientInteraction.type)
  return static_cast< ::underworlds::ClientInteraction_InteractionType >(type_);
}
inline void ClientInteraction::set_type(::underworlds::ClientInteraction_InteractionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:underworlds.ClientInteraction.type)
}

// optional .underworlds.Time last_activity = 3;
inline bool ClientInteraction::has_last_activity() const {
  return !_is_default_instance_ && last_activity_ != NULL;
}
inline void ClientInteraction::clear_last_activity() {
  if (GetArenaNoVirtual() == NULL && last_activity_ != NULL) delete last_activity_;
  last_activity_ = NULL;
}
inline const ::underworlds::Time& ClientInteraction::last_activity() const {
  // @@protoc_insertion_point(field_get:underworlds.ClientInteraction.last_activity)
  return last_activity_ != NULL ? *last_activity_ : *default_instance_->last_activity_;
}
inline ::underworlds::Time* ClientInteraction::mutable_last_activity() {
  
  if (last_activity_ == NULL) {
    last_activity_ = new ::underworlds::Time;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.ClientInteraction.last_activity)
  return last_activity_;
}
inline ::underworlds::Time* ClientInteraction::release_last_activity() {
  // @@protoc_insertion_point(field_release:underworlds.ClientInteraction.last_activity)
  
  ::underworlds::Time* temp = last_activity_;
  last_activity_ = NULL;
  return temp;
}
inline void ClientInteraction::set_allocated_last_activity(::underworlds::Time* last_activity) {
  delete last_activity_;
  last_activity_ = last_activity;
  if (last_activity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.ClientInteraction.last_activity)
}

// -------------------------------------------------------------------

// Context

// optional string client = 1;
inline void Context::clear_client() {
  client_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Context::client() const {
  // @@protoc_insertion_point(field_get:underworlds.Context.client)
  return client_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_client(const ::std::string& value) {
  
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Context.client)
}
inline void Context::set_client(const char* value) {
  
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Context.client)
}
inline void Context::set_client(const char* value, size_t size) {
  
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Context.client)
}
inline ::std::string* Context::mutable_client() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Context.client)
  return client_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Context::release_client() {
  // @@protoc_insertion_point(field_release:underworlds.Context.client)
  
  return client_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_allocated_client(::std::string* client) {
  if (client != NULL) {
    
  } else {
    
  }
  client_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Context.client)
}

// optional string world = 2;
inline void Context::clear_world() {
  world_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Context::world() const {
  // @@protoc_insertion_point(field_get:underworlds.Context.world)
  return world_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_world(const ::std::string& value) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Context.world)
}
inline void Context::set_world(const char* value) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Context.world)
}
inline void Context::set_world(const char* value, size_t size) {
  
  world_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Context.world)
}
inline ::std::string* Context::mutable_world() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Context.world)
  return world_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Context::release_world() {
  // @@protoc_insertion_point(field_release:underworlds.Context.world)
  
  return world_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_allocated_world(::std::string* world) {
  if (world != NULL) {
    
  } else {
    
  }
  world_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), world);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Context.world)
}

// -------------------------------------------------------------------

// Topology

// repeated string worlds = 1;
inline int Topology::worlds_size() const {
  return worlds_.size();
}
inline void Topology::clear_worlds() {
  worlds_.Clear();
}
inline const ::std::string& Topology::worlds(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Topology.worlds)
  return worlds_.Get(index);
}
inline ::std::string* Topology::mutable_worlds(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Topology.worlds)
  return worlds_.Mutable(index);
}
inline void Topology::set_worlds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Topology.worlds)
  worlds_.Mutable(index)->assign(value);
}
inline void Topology::set_worlds(int index, const char* value) {
  worlds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Topology.worlds)
}
inline void Topology::set_worlds(int index, const char* value, size_t size) {
  worlds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Topology.worlds)
}
inline ::std::string* Topology::add_worlds() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Topology.worlds)
  return worlds_.Add();
}
inline void Topology::add_worlds(const ::std::string& value) {
  worlds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Topology.worlds)
}
inline void Topology::add_worlds(const char* value) {
  worlds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Topology.worlds)
}
inline void Topology::add_worlds(const char* value, size_t size) {
  worlds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Topology.worlds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Topology::worlds() const {
  // @@protoc_insertion_point(field_list:underworlds.Topology.worlds)
  return worlds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Topology::mutable_worlds() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Topology.worlds)
  return &worlds_;
}

// repeated .underworlds.Client clients = 2;
inline int Topology::clients_size() const {
  return clients_.size();
}
inline void Topology::clear_clients() {
  clients_.Clear();
}
inline const ::underworlds::Client& Topology::clients(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Topology.clients)
  return clients_.Get(index);
}
inline ::underworlds::Client* Topology::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Topology.clients)
  return clients_.Mutable(index);
}
inline ::underworlds::Client* Topology::add_clients() {
  // @@protoc_insertion_point(field_add:underworlds.Topology.clients)
  return clients_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::Client >*
Topology::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Topology.clients)
  return &clients_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::Client >&
Topology::clients() const {
  // @@protoc_insertion_point(field_list:underworlds.Topology.clients)
  return clients_;
}

// -------------------------------------------------------------------

// Node

// optional string id = 1;
inline void Node::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Node.id)
}
inline void Node::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Node.id)
}
inline void Node::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.id)
}
inline ::std::string* Node::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Node.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.Node.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Node.id)
}

// optional string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Node.name)
}
inline void Node::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:underworlds.Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Node.name)
}

// optional .underworlds.Node.NodeType type = 3;
inline void Node::clear_type() {
  type_ = 0;
}
inline ::underworlds::Node_NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.type)
  return static_cast< ::underworlds::Node_NodeType >(type_);
}
inline void Node::set_type(::underworlds::Node_NodeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.type)
}

// optional string parent = 4;
inline void Node::clear_parent() {
  parent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::parent() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.parent)
  return parent_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_parent(const ::std::string& value) {
  
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Node.parent)
}
inline void Node::set_parent(const char* value) {
  
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Node.parent)
}
inline void Node::set_parent(const char* value, size_t size) {
  
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.parent)
}
inline ::std::string* Node::mutable_parent() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Node.parent)
  return parent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_parent() {
  // @@protoc_insertion_point(field_release:underworlds.Node.parent)
  
  return parent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_parent(::std::string* parent) {
  if (parent != NULL) {
    
  } else {
    
  }
  parent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Node.parent)
}

// repeated string children = 5;
inline int Node::children_size() const {
  return children_.size();
}
inline void Node::clear_children() {
  children_.Clear();
}
inline const ::std::string& Node::children(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.children)
  return children_.Get(index);
}
inline ::std::string* Node::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Node.children)
  return children_.Mutable(index);
}
inline void Node::set_children(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Node.children)
  children_.Mutable(index)->assign(value);
}
inline void Node::set_children(int index, const char* value) {
  children_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Node.children)
}
inline void Node::set_children(int index, const char* value, size_t size) {
  children_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.children)
}
inline ::std::string* Node::add_children() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Node.children)
  return children_.Add();
}
inline void Node::add_children(const ::std::string& value) {
  children_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Node.children)
}
inline void Node::add_children(const char* value) {
  children_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Node.children)
}
inline void Node::add_children(const char* value, size_t size) {
  children_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Node.children)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::children() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.children)
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.children)
  return &children_;
}

// repeated float transformation = 6;
inline int Node::transformation_size() const {
  return transformation_.size();
}
inline void Node::clear_transformation() {
  transformation_.Clear();
}
inline float Node::transformation(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.transformation)
  return transformation_.Get(index);
}
inline void Node::set_transformation(int index, float value) {
  transformation_.Set(index, value);
  // @@protoc_insertion_point(field_set:underworlds.Node.transformation)
}
inline void Node::add_transformation(float value) {
  transformation_.Add(value);
  // @@protoc_insertion_point(field_add:underworlds.Node.transformation)
}
inline const ::google::protobuf::RepeatedField< float >&
Node::transformation() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.transformation)
  return transformation_;
}
inline ::google::protobuf::RepeatedField< float >*
Node::mutable_transformation() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.transformation)
  return &transformation_;
}

// optional double last_update = 8;
inline void Node::clear_last_update() {
  last_update_ = 0;
}
inline double Node::last_update() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.last_update)
  return last_update_;
}
inline void Node::set_last_update(double value) {
  
  last_update_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.last_update)
}

// repeated string lowres = 16;
inline int Node::lowres_size() const {
  return lowres_.size();
}
inline void Node::clear_lowres() {
  lowres_.Clear();
}
inline const ::std::string& Node::lowres(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.lowres)
  return lowres_.Get(index);
}
inline ::std::string* Node::mutable_lowres(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Node.lowres)
  return lowres_.Mutable(index);
}
inline void Node::set_lowres(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Node.lowres)
  lowres_.Mutable(index)->assign(value);
}
inline void Node::set_lowres(int index, const char* value) {
  lowres_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Node.lowres)
}
inline void Node::set_lowres(int index, const char* value, size_t size) {
  lowres_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.lowres)
}
inline ::std::string* Node::add_lowres() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Node.lowres)
  return lowres_.Add();
}
inline void Node::add_lowres(const ::std::string& value) {
  lowres_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Node.lowres)
}
inline void Node::add_lowres(const char* value) {
  lowres_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Node.lowres)
}
inline void Node::add_lowres(const char* value, size_t size) {
  lowres_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Node.lowres)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::lowres() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.lowres)
  return lowres_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_lowres() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.lowres)
  return &lowres_;
}

// repeated string hires = 17;
inline int Node::hires_size() const {
  return hires_.size();
}
inline void Node::clear_hires() {
  hires_.Clear();
}
inline const ::std::string& Node::hires(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.hires)
  return hires_.Get(index);
}
inline ::std::string* Node::mutable_hires(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Node.hires)
  return hires_.Mutable(index);
}
inline void Node::set_hires(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Node.hires)
  hires_.Mutable(index)->assign(value);
}
inline void Node::set_hires(int index, const char* value) {
  hires_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Node.hires)
}
inline void Node::set_hires(int index, const char* value, size_t size) {
  hires_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.hires)
}
inline ::std::string* Node::add_hires() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Node.hires)
  return hires_.Add();
}
inline void Node::add_hires(const ::std::string& value) {
  hires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Node.hires)
}
inline void Node::add_hires(const char* value) {
  hires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Node.hires)
}
inline void Node::add_hires(const char* value, size_t size) {
  hires_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Node.hires)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::hires() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.hires)
  return hires_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_hires() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.hires)
  return &hires_;
}

// repeated string cad = 18;
inline int Node::cad_size() const {
  return cad_.size();
}
inline void Node::clear_cad() {
  cad_.Clear();
}
inline const ::std::string& Node::cad(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.cad)
  return cad_.Get(index);
}
inline ::std::string* Node::mutable_cad(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Node.cad)
  return cad_.Mutable(index);
}
inline void Node::set_cad(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Node.cad)
  cad_.Mutable(index)->assign(value);
}
inline void Node::set_cad(int index, const char* value) {
  cad_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Node.cad)
}
inline void Node::set_cad(int index, const char* value, size_t size) {
  cad_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Node.cad)
}
inline ::std::string* Node::add_cad() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Node.cad)
  return cad_.Add();
}
inline void Node::add_cad(const ::std::string& value) {
  cad_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Node.cad)
}
inline void Node::add_cad(const char* value) {
  cad_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Node.cad)
}
inline void Node::add_cad(const char* value, size_t size) {
  cad_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Node.cad)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::cad() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.cad)
  return cad_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_cad() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.cad)
  return &cad_;
}

// repeated .underworlds.Pointf aabb = 19;
inline int Node::aabb_size() const {
  return aabb_.size();
}
inline void Node::clear_aabb() {
  aabb_.Clear();
}
inline const ::underworlds::Pointf& Node::aabb(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Node.aabb)
  return aabb_.Get(index);
}
inline ::underworlds::Pointf* Node::mutable_aabb(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Node.aabb)
  return aabb_.Mutable(index);
}
inline ::underworlds::Pointf* Node::add_aabb() {
  // @@protoc_insertion_point(field_add:underworlds.Node.aabb)
  return aabb_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
Node::mutable_aabb() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Node.aabb)
  return &aabb_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
Node::aabb() const {
  // @@protoc_insertion_point(field_list:underworlds.Node.aabb)
  return aabb_;
}

// optional bool physics = 30;
inline void Node::clear_physics() {
  physics_ = false;
}
inline bool Node::physics() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.physics)
  return physics_;
}
inline void Node::set_physics(bool value) {
  
  physics_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.physics)
}

// optional float clipplanenear = 40;
inline void Node::clear_clipplanenear() {
  clipplanenear_ = 0;
}
inline float Node::clipplanenear() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.clipplanenear)
  return clipplanenear_;
}
inline void Node::set_clipplanenear(float value) {
  
  clipplanenear_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.clipplanenear)
}

// optional float clipplanefar = 41;
inline void Node::clear_clipplanefar() {
  clipplanefar_ = 0;
}
inline float Node::clipplanefar() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.clipplanefar)
  return clipplanefar_;
}
inline void Node::set_clipplanefar(float value) {
  
  clipplanefar_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.clipplanefar)
}

// optional float aspect = 42;
inline void Node::clear_aspect() {
  aspect_ = 0;
}
inline float Node::aspect() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.aspect)
  return aspect_;
}
inline void Node::set_aspect(float value) {
  
  aspect_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.aspect)
}

// optional float horizontalfov = 43;
inline void Node::clear_horizontalfov() {
  horizontalfov_ = 0;
}
inline float Node::horizontalfov() const {
  // @@protoc_insertion_point(field_get:underworlds.Node.horizontalfov)
  return horizontalfov_;
}
inline void Node::set_horizontalfov(float value) {
  
  horizontalfov_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Node.horizontalfov)
}

// -------------------------------------------------------------------

// Nodes

// repeated string ids = 1;
inline int Nodes::ids_size() const {
  return ids_.size();
}
inline void Nodes::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& Nodes::ids(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Nodes.ids)
  return ids_.Get(index);
}
inline ::std::string* Nodes::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Nodes.ids)
  return ids_.Mutable(index);
}
inline void Nodes::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:underworlds.Nodes.ids)
  ids_.Mutable(index)->assign(value);
}
inline void Nodes::set_ids(int index, const char* value) {
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:underworlds.Nodes.ids)
}
inline void Nodes::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:underworlds.Nodes.ids)
}
inline ::std::string* Nodes::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:underworlds.Nodes.ids)
  return ids_.Add();
}
inline void Nodes::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:underworlds.Nodes.ids)
}
inline void Nodes::add_ids(const char* value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:underworlds.Nodes.ids)
}
inline void Nodes::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:underworlds.Nodes.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Nodes::ids() const {
  // @@protoc_insertion_point(field_list:underworlds.Nodes.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Nodes::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Nodes.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// NodeInContext

// optional .underworlds.Context context = 1;
inline bool NodeInContext::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void NodeInContext::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::underworlds::Context& NodeInContext::context() const {
  // @@protoc_insertion_point(field_get:underworlds.NodeInContext.context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::underworlds::Context* NodeInContext::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::underworlds::Context;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.NodeInContext.context)
  return context_;
}
inline ::underworlds::Context* NodeInContext::release_context() {
  // @@protoc_insertion_point(field_release:underworlds.NodeInContext.context)
  
  ::underworlds::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void NodeInContext::set_allocated_context(::underworlds::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.NodeInContext.context)
}

// optional .underworlds.Node node = 2;
inline bool NodeInContext::has_node() const {
  return !_is_default_instance_ && node_ != NULL;
}
inline void NodeInContext::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::underworlds::Node& NodeInContext::node() const {
  // @@protoc_insertion_point(field_get:underworlds.NodeInContext.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::underworlds::Node* NodeInContext::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::underworlds::Node;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.NodeInContext.node)
  return node_;
}
inline ::underworlds::Node* NodeInContext::release_node() {
  // @@protoc_insertion_point(field_release:underworlds.NodeInContext.node)
  
  ::underworlds::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void NodeInContext::set_allocated_node(::underworlds::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.NodeInContext.node)
}

// -------------------------------------------------------------------

// NodeInvalidation

// optional .underworlds.NodeInvalidation.NodeInvalidationType type = 1;
inline void NodeInvalidation::clear_type() {
  type_ = 0;
}
inline ::underworlds::NodeInvalidation_NodeInvalidationType NodeInvalidation::type() const {
  // @@protoc_insertion_point(field_get:underworlds.NodeInvalidation.type)
  return static_cast< ::underworlds::NodeInvalidation_NodeInvalidationType >(type_);
}
inline void NodeInvalidation::set_type(::underworlds::NodeInvalidation_NodeInvalidationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:underworlds.NodeInvalidation.type)
}

// optional string id = 2;
inline void NodeInvalidation::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInvalidation::id() const {
  // @@protoc_insertion_point(field_get:underworlds.NodeInvalidation.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInvalidation::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.NodeInvalidation.id)
}
inline void NodeInvalidation::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.NodeInvalidation.id)
}
inline void NodeInvalidation::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.NodeInvalidation.id)
}
inline ::std::string* NodeInvalidation::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.NodeInvalidation.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInvalidation::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.NodeInvalidation.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInvalidation::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.NodeInvalidation.id)
}

// -------------------------------------------------------------------

// Situation

// optional string id = 1;
inline void Situation::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Situation::id() const {
  // @@protoc_insertion_point(field_get:underworlds.Situation.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Situation::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Situation.id)
}
inline void Situation::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Situation.id)
}
inline void Situation::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Situation.id)
}
inline ::std::string* Situation::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Situation.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Situation::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.Situation.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Situation::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Situation.id)
}

// optional .underworlds.Situation.SituationType type = 2;
inline void Situation::clear_type() {
  type_ = 0;
}
inline ::underworlds::Situation_SituationType Situation::type() const {
  // @@protoc_insertion_point(field_get:underworlds.Situation.type)
  return static_cast< ::underworlds::Situation_SituationType >(type_);
}
inline void Situation::set_type(::underworlds::Situation_SituationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:underworlds.Situation.type)
}

// optional string description = 3;
inline void Situation::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Situation::description() const {
  // @@protoc_insertion_point(field_get:underworlds.Situation.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Situation::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Situation.description)
}
inline void Situation::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Situation.description)
}
inline void Situation::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Situation.description)
}
inline ::std::string* Situation::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Situation.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Situation::release_description() {
  // @@protoc_insertion_point(field_release:underworlds.Situation.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Situation::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Situation.description)
}

// optional .underworlds.Time start = 4;
inline bool Situation::has_start() const {
  return !_is_default_instance_ && start_ != NULL;
}
inline void Situation::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
inline const ::underworlds::Time& Situation::start() const {
  // @@protoc_insertion_point(field_get:underworlds.Situation.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::underworlds::Time* Situation::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::underworlds::Time;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.Situation.start)
  return start_;
}
inline ::underworlds::Time* Situation::release_start() {
  // @@protoc_insertion_point(field_release:underworlds.Situation.start)
  
  ::underworlds::Time* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Situation::set_allocated_start(::underworlds::Time* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.Situation.start)
}

// optional .underworlds.Time end = 5;
inline bool Situation::has_end() const {
  return !_is_default_instance_ && end_ != NULL;
}
inline void Situation::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) delete end_;
  end_ = NULL;
}
inline const ::underworlds::Time& Situation::end() const {
  // @@protoc_insertion_point(field_get:underworlds.Situation.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::underworlds::Time* Situation::mutable_end() {
  
  if (end_ == NULL) {
    end_ = new ::underworlds::Time;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.Situation.end)
  return end_;
}
inline ::underworlds::Time* Situation::release_end() {
  // @@protoc_insertion_point(field_release:underworlds.Situation.end)
  
  ::underworlds::Time* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Situation::set_allocated_end(::underworlds::Time* end) {
  delete end_;
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.Situation.end)
}

// -------------------------------------------------------------------

// SituationInContext

// optional .underworlds.Context context = 1;
inline bool SituationInContext::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void SituationInContext::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::underworlds::Context& SituationInContext::context() const {
  // @@protoc_insertion_point(field_get:underworlds.SituationInContext.context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::underworlds::Context* SituationInContext::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::underworlds::Context;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.SituationInContext.context)
  return context_;
}
inline ::underworlds::Context* SituationInContext::release_context() {
  // @@protoc_insertion_point(field_release:underworlds.SituationInContext.context)
  
  ::underworlds::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void SituationInContext::set_allocated_context(::underworlds::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.SituationInContext.context)
}

// optional .underworlds.Situation situation = 2;
inline bool SituationInContext::has_situation() const {
  return !_is_default_instance_ && situation_ != NULL;
}
inline void SituationInContext::clear_situation() {
  if (GetArenaNoVirtual() == NULL && situation_ != NULL) delete situation_;
  situation_ = NULL;
}
inline const ::underworlds::Situation& SituationInContext::situation() const {
  // @@protoc_insertion_point(field_get:underworlds.SituationInContext.situation)
  return situation_ != NULL ? *situation_ : *default_instance_->situation_;
}
inline ::underworlds::Situation* SituationInContext::mutable_situation() {
  
  if (situation_ == NULL) {
    situation_ = new ::underworlds::Situation;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.SituationInContext.situation)
  return situation_;
}
inline ::underworlds::Situation* SituationInContext::release_situation() {
  // @@protoc_insertion_point(field_release:underworlds.SituationInContext.situation)
  
  ::underworlds::Situation* temp = situation_;
  situation_ = NULL;
  return temp;
}
inline void SituationInContext::set_allocated_situation(::underworlds::Situation* situation) {
  delete situation_;
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.SituationInContext.situation)
}

// -------------------------------------------------------------------

// TimelineInvalidation

// optional .underworlds.TimelineInvalidation.TimelineInvalidationType type = 1;
inline void TimelineInvalidation::clear_type() {
  type_ = 0;
}
inline ::underworlds::TimelineInvalidation_TimelineInvalidationType TimelineInvalidation::type() const {
  // @@protoc_insertion_point(field_get:underworlds.TimelineInvalidation.type)
  return static_cast< ::underworlds::TimelineInvalidation_TimelineInvalidationType >(type_);
}
inline void TimelineInvalidation::set_type(::underworlds::TimelineInvalidation_TimelineInvalidationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:underworlds.TimelineInvalidation.type)
}

// optional string id = 2;
inline void TimelineInvalidation::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TimelineInvalidation::id() const {
  // @@protoc_insertion_point(field_get:underworlds.TimelineInvalidation.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimelineInvalidation::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.TimelineInvalidation.id)
}
inline void TimelineInvalidation::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.TimelineInvalidation.id)
}
inline void TimelineInvalidation::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.TimelineInvalidation.id)
}
inline ::std::string* TimelineInvalidation::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.TimelineInvalidation.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TimelineInvalidation::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.TimelineInvalidation.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimelineInvalidation::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.TimelineInvalidation.id)
}

// -------------------------------------------------------------------

// Mesh

// optional string id = 1;
inline void Mesh::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mesh::id() const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:underworlds.Mesh.id)
}
inline void Mesh::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:underworlds.Mesh.id)
}
inline void Mesh::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:underworlds.Mesh.id)
}
inline ::std::string* Mesh::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:underworlds.Mesh.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_id() {
  // @@protoc_insertion_point(field_release:underworlds.Mesh.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:underworlds.Mesh.id)
}

// repeated .underworlds.Pointf vertices = 2;
inline int Mesh::vertices_size() const {
  return vertices_.size();
}
inline void Mesh::clear_vertices() {
  vertices_.Clear();
}
inline const ::underworlds::Pointf& Mesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.vertices)
  return vertices_.Get(index);
}
inline ::underworlds::Pointf* Mesh::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Mesh.vertices)
  return vertices_.Mutable(index);
}
inline ::underworlds::Pointf* Mesh::add_vertices() {
  // @@protoc_insertion_point(field_add:underworlds.Mesh.vertices)
  return vertices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
Mesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Mesh.vertices)
  return &vertices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
Mesh::vertices() const {
  // @@protoc_insertion_point(field_list:underworlds.Mesh.vertices)
  return vertices_;
}

// repeated .underworlds.Point faces = 3;
inline int Mesh::faces_size() const {
  return faces_.size();
}
inline void Mesh::clear_faces() {
  faces_.Clear();
}
inline const ::underworlds::Point& Mesh::faces(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.faces)
  return faces_.Get(index);
}
inline ::underworlds::Point* Mesh::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Mesh.faces)
  return faces_.Mutable(index);
}
inline ::underworlds::Point* Mesh::add_faces() {
  // @@protoc_insertion_point(field_add:underworlds.Mesh.faces)
  return faces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::Point >*
Mesh::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Mesh.faces)
  return &faces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::Point >&
Mesh::faces() const {
  // @@protoc_insertion_point(field_list:underworlds.Mesh.faces)
  return faces_;
}

// repeated .underworlds.Pointf normals = 4;
inline int Mesh::normals_size() const {
  return normals_.size();
}
inline void Mesh::clear_normals() {
  normals_.Clear();
}
inline const ::underworlds::Pointf& Mesh::normals(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.normals)
  return normals_.Get(index);
}
inline ::underworlds::Pointf* Mesh::mutable_normals(int index) {
  // @@protoc_insertion_point(field_mutable:underworlds.Mesh.normals)
  return normals_.Mutable(index);
}
inline ::underworlds::Pointf* Mesh::add_normals() {
  // @@protoc_insertion_point(field_add:underworlds.Mesh.normals)
  return normals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >*
Mesh::mutable_normals() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Mesh.normals)
  return &normals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::underworlds::Pointf >&
Mesh::normals() const {
  // @@protoc_insertion_point(field_list:underworlds.Mesh.normals)
  return normals_;
}

// repeated uint32 colors = 5;
inline int Mesh::colors_size() const {
  return colors_.size();
}
inline void Mesh::clear_colors() {
  colors_.Clear();
}
inline ::google::protobuf::uint32 Mesh::colors(int index) const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.colors)
  return colors_.Get(index);
}
inline void Mesh::set_colors(int index, ::google::protobuf::uint32 value) {
  colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:underworlds.Mesh.colors)
}
inline void Mesh::add_colors(::google::protobuf::uint32 value) {
  colors_.Add(value);
  // @@protoc_insertion_point(field_add:underworlds.Mesh.colors)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Mesh::colors() const {
  // @@protoc_insertion_point(field_list:underworlds.Mesh.colors)
  return colors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Mesh::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:underworlds.Mesh.colors)
  return &colors_;
}

// optional .underworlds.Color diffuse = 6;
inline bool Mesh::has_diffuse() const {
  return !_is_default_instance_ && diffuse_ != NULL;
}
inline void Mesh::clear_diffuse() {
  if (GetArenaNoVirtual() == NULL && diffuse_ != NULL) delete diffuse_;
  diffuse_ = NULL;
}
inline const ::underworlds::Color& Mesh::diffuse() const {
  // @@protoc_insertion_point(field_get:underworlds.Mesh.diffuse)
  return diffuse_ != NULL ? *diffuse_ : *default_instance_->diffuse_;
}
inline ::underworlds::Color* Mesh::mutable_diffuse() {
  
  if (diffuse_ == NULL) {
    diffuse_ = new ::underworlds::Color;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.Mesh.diffuse)
  return diffuse_;
}
inline ::underworlds::Color* Mesh::release_diffuse() {
  // @@protoc_insertion_point(field_release:underworlds.Mesh.diffuse)
  
  ::underworlds::Color* temp = diffuse_;
  diffuse_ = NULL;
  return temp;
}
inline void Mesh::set_allocated_diffuse(::underworlds::Color* diffuse) {
  delete diffuse_;
  diffuse_ = diffuse;
  if (diffuse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.Mesh.diffuse)
}

// -------------------------------------------------------------------

// MeshInContext

// optional .underworlds.Client client = 1;
inline bool MeshInContext::has_client() const {
  return !_is_default_instance_ && client_ != NULL;
}
inline void MeshInContext::clear_client() {
  if (GetArenaNoVirtual() == NULL && client_ != NULL) delete client_;
  client_ = NULL;
}
inline const ::underworlds::Client& MeshInContext::client() const {
  // @@protoc_insertion_point(field_get:underworlds.MeshInContext.client)
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::underworlds::Client* MeshInContext::mutable_client() {
  
  if (client_ == NULL) {
    client_ = new ::underworlds::Client;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.MeshInContext.client)
  return client_;
}
inline ::underworlds::Client* MeshInContext::release_client() {
  // @@protoc_insertion_point(field_release:underworlds.MeshInContext.client)
  
  ::underworlds::Client* temp = client_;
  client_ = NULL;
  return temp;
}
inline void MeshInContext::set_allocated_client(::underworlds::Client* client) {
  delete client_;
  client_ = client;
  if (client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.MeshInContext.client)
}

// optional .underworlds.Mesh mesh = 2;
inline bool MeshInContext::has_mesh() const {
  return !_is_default_instance_ && mesh_ != NULL;
}
inline void MeshInContext::clear_mesh() {
  if (GetArenaNoVirtual() == NULL && mesh_ != NULL) delete mesh_;
  mesh_ = NULL;
}
inline const ::underworlds::Mesh& MeshInContext::mesh() const {
  // @@protoc_insertion_point(field_get:underworlds.MeshInContext.mesh)
  return mesh_ != NULL ? *mesh_ : *default_instance_->mesh_;
}
inline ::underworlds::Mesh* MeshInContext::mutable_mesh() {
  
  if (mesh_ == NULL) {
    mesh_ = new ::underworlds::Mesh;
  }
  // @@protoc_insertion_point(field_mutable:underworlds.MeshInContext.mesh)
  return mesh_;
}
inline ::underworlds::Mesh* MeshInContext::release_mesh() {
  // @@protoc_insertion_point(field_release:underworlds.MeshInContext.mesh)
  
  ::underworlds::Mesh* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline void MeshInContext::set_allocated_mesh(::underworlds::Mesh* mesh) {
  delete mesh_;
  mesh_ = mesh;
  if (mesh) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:underworlds.MeshInContext.mesh)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace underworlds

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::underworlds::ClientInteraction_InteractionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::underworlds::ClientInteraction_InteractionType>() {
  return ::underworlds::ClientInteraction_InteractionType_descriptor();
}
template <> struct is_proto_enum< ::underworlds::Node_NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::underworlds::Node_NodeType>() {
  return ::underworlds::Node_NodeType_descriptor();
}
template <> struct is_proto_enum< ::underworlds::NodeInvalidation_NodeInvalidationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::underworlds::NodeInvalidation_NodeInvalidationType>() {
  return ::underworlds::NodeInvalidation_NodeInvalidationType_descriptor();
}
template <> struct is_proto_enum< ::underworlds::Situation_SituationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::underworlds::Situation_SituationType>() {
  return ::underworlds::Situation_SituationType_descriptor();
}
template <> struct is_proto_enum< ::underworlds::TimelineInvalidation_TimelineInvalidationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::underworlds::TimelineInvalidation_TimelineInvalidationType>() {
  return ::underworlds::TimelineInvalidation_TimelineInvalidationType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_underworlds_2eproto__INCLUDED
